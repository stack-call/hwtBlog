---
title: 函数调用
description: 了解汇编程序的函数调用
tags: [Assembly]
---

## X86和X86_64的调用约定
我们知道，函数调用是caller(调用方)跳转到callee(被调用方)，并传递参数，返回值的过程。在这个过程中，我们可以通过寄存器传参，通过栈传参。要想不同的函数调用可以兼容，我们便需要为函数调用建立一个"约定"或者"规范"。这便是函数调用约定。
:::info
* call指令其实可以分为两步，1：把下一条指令的地址压入栈中，2：转移到调用的子程序。
* ret指令相当于 1：pop ip，2：将堆栈指针减去2
:::
## cdecl(32位)
cdecl(C declaration)调用约定是32位平台非常常见的一种约定，也即是C语言所采取的调用约定。cdecl有四个特征：
* 参数按照相反的顺序(也就是从右到左的顺序)入栈
* eax, ecx及edx需要由调用方保存(叫作易失性的寄存器)，而其余的通用寄存器则由受调方来保存(叫作非易失性的寄存器)。因此，如果想令eax，ecx及edx寄存器在调用完后还能保持调用前的值，那么主调函数应该将其保存起来，因为被调函数运行过程中可能修改其值。
* 在大多数情况下，返回值放在eax寄存器中，如果返回浮点数，那么放在st(0)寄存器中。
* 栈由调用方清理

:::tip
C语言支持参数数量可变的函数，因此，被调方不知道自己到底接收了几个参数。因此要求栈由主调方清理。例如C语言中的<code>int printf(const char *format, ...);</code>
:::
## stdcall(32位)
stadcall在Windows API中被应用。一般来说，其规则和cdecl相同，只是一个地方有区别。
* 参数按照相反顺序入栈
* eax，ecx，edx由调用方保存，其余由被调方保存
* 返回值在eax或st(0)
* **栈由被调方清理**

:::info
cdecl调用过程
```asm title=cdecl函数调用
    pushl num2
    pushl num1
    calll _sum
    addl $8, %esp

...

_sum:
    pushl %ebp
    movl %esp, %ebp

    ...

    popl %ebp
    retl

```
根据调用约定，我们对照代码可以发现，在调用_sum后，由主调方清理了栈。

同样，我们可以发现每一个32位函数的开头和结尾都是类似的代码段，这是因为32位环境下和64位环境下引用栈中局部值的方式不同。  
32位环境下，一般以ebp为基准访问参数，esp仅仅指向栈顶。函数中的这一段代码就算在为自己建立栈帧。  
64位环境下不这样使用。原因：1.64位下一般使用寄存器传递参数。2.64位下有RIP相对寻址机制。3.64位中系统默认在栈中划分一段**暂存空间**，使得我们可以直接以rsp为基准访问变量。

:::

## x86_64(64位)
64位架构出现后，函数的调用约定比较规范，在同一套大的约定规范下形成了两个小的风格。Microsoft x64和System V AMD64(AMD64)。
![](https://img-blog.csdnimg.cn/771af2f950d54c9ba26679ca320991b0.png)
