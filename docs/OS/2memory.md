---
title: 操作系统内存管理
description: 介绍操作系统的内存管理
tags: [Operating System]
---

## 要处理的问题
(这一段可以参考《程序员的自我修养——装载、链接与库》)
1. 需要尽可能的做到内存的充分利用(内存使用效率)
2. 地址空间不隔离，需要实现对内存的访问保护(防止恶意程序篡改)
3. 重定位问题。程序加载位置不确定因此对于许多jmp指令会不能正确跳转
### 直接使用物理空间
对于早期的操作系统访问内存，对内存的访问都是简单的，程序通过直接访问物理地址来进行编程。在这种情况下，内存的使用是不安全的，利用是不充分的，任何程序都可以访问相同的地址。当然，单个程序是没有问题的，但是对应多个程序，以上的所有问题都无法解决。

### 分段
对于不同程序内存的互相影响，我们可以想到的最简单的方法就是为每个程序划定一个内存空间，将某个程序限制在其自己的内存空间内，这样不就解决了对内存的混乱使用问题。因此，CPU设计者增加了相关分段部件，使用段+段内偏移的方式访问内存。同时，对于重定位问题，每个程序只需要关注自己的偏移就可以了。这个时候，我们可以稳定的允许多个程序了，但是我们知道，程序的内存占用是在不断变换的，这样，在两个程序段中间就会有一段难以利用的内存。**这个时候，分段对内存区域的映射还是以程序为单位**。如果内存不足，我们需要使用将暂时不用的程序放入磁盘中，从而严重影响速度。而事实上，根据程序的局部性原理，一段程序在一个时间段内只会用到一部分，因此，我们自然可以想到加载程序中一部分的代码来提高内存使用效率。  
同时，如果使用分段，我们同样可以以任务代码段、数据或栈为单位来进行隔离，从而达到多进程或多任务能够在同一个处理器上允行而不会互相干扰。  
Intel开发者手册中对其分段模式有这样的描述，分段提供了一种隔离每个进程或者任务代码、数据或栈模块的机制，保证多个进程或者任务能够在同一个处理器上允许而不会互相干扰。其中实模式和保护模式都有分段，基本概念相似，但是保护模式比实地址模式多了分段保护，这也是保护模式的核心。

### 分页
为了只加载一部分代码，我们需要将程序进行分割，为了减少分割的复杂问题，我们可以直接把程序划分为固定大小，那么这个时候，程序加载到内存中也只会是一个固定大小，因此，我们同时可以对内存进行固定大小的划分，划分成和程序块相同的大小，这样因为程序大小不同而产生的无法利用的内存碎片也不会存在了。但是我们知道程序是一个整体，就算程序会经常允许部分代码，但是其他部分总是会执行。那么如果我们需要jmp到那一部分代码的时候，我们的内存中是没有的，那这不就会产生严重错误了吗。那么这个时候我们应该怎么办呢。解决方法就是在程序和实际内存之间增加一个中间层，这个中间层就算虚拟地址。即我们想办法实现这样一个中间层，对于程序来说，让其觉得是在访问实际的地址，但是对于实际的实现来说，却仅仅是加载部分程序，仅仅当跳转到未加载到内存中的程序段的时候再将跳转到的程序段加载到内存，但是这个过程程序是不知道的，它只会觉得它的程序是完全被加载到内存中的。很显然，仅仅使用编程是无法实现的，因为对地址的访问转换不是程序所能控制的，因此CPU设计者便增加了相关的电子部件，这就是虚拟分页部件。  
这个时候，对于虚拟地址空间的每一个块中的地址，经过分页部件的转换会映射到某个物理地址块的相应地址。也就是说，分页不仅仅实现了我们相要的功能，我们可以发现其实际上就是一个内存的映射(中间层)
:::tip
这个时候我们可以发现，这种情况下对于每个程序来说自己都是独占全部的内存空间，因此我们似乎又不用使用分段机制了，因为不会遇到重定位和内存充分利用的问题，因此Linux操作系统只使用了分页机制，几乎没有使用分段机制。因为分页机制几乎就算是高级的分段机制。
:::

## 操作系统内存管理设计
了解了基本的知识，我们应该如何设计操作系统的内存管理呢。
1. 将程序要使用的物理内存分成固定大小的内存块
2. 对物理内存块进行管理工作，管理其分配，回收
3. 建立分页机制，建立虚拟内存空间与物理地址空间的映射(不考虑分段机制)线性地址---分段--->虚拟地址---分页--->物理地址

首先，我们要明白的是，我们只需要对主内存(程序使用的内存)进行管理，操作系统的核心代码可以不进行管理。同时，对于文件系统所要处理的低速设备，我们需要为其再内存中开辟一个高速缓存(相对于硬盘等低速设备)，并为虚拟盘提供必要的缓冲空间，因此我们需要从内存中划分走一部分内存，剩下的才算是主内存。

内存共享：如果两个进程访问相同的内存，并且都没有进行写操作，那么为了节省内存空间的使用，我们可以让这两个进程共享这页内存，此时我们便可以达到节省内存的目的。

## Linux0.12的内存管理实现

### 物理内存初始化
最简单的想法就是使用一个数组，用数组的值来表示内存的使用。因此，Linux0.12使用mem_map来表示主内存中物理内存块的使用情况。注意这只是主内存区。我们使用内存的值来表示内存的使用情况，并且我们需要实现内存共享，因此一个页面可能有多个使用，因此我们使用数组的值表示使用这页内存被多少项使用，但是同时我们需要规定一个上限，在这里使用了#define USED 100，

### 物理内存的分配和回收
get_free_page()和free_page()分别用来对物理内存进行分配和回收。  
获取内存时只需要在mem_map中寻找到一个空闲项(即值为0)，并寻找到其对应的物理地址并返回就可以。  
回收内存时情况会复杂一些，还需要考虑共享内存的情况，因此我们先将其值减一，当其为0时也不需要对其内容清0，我们可以在申请内存的get_free_page()中对其清0.
:::tip
get_free_page()只分配为0的物理页面，而free_page()时则会有共享内存，即值可能大于1，因为这是在内存允行过程中产生新进程时使用相同页面时才会共享，而不是分配物理页面时共享。
:::

### 线性地址与物理地址间的页面映射

分页机制都是通过对页表的编写来进行的。  
我们需要对应的函数来进行物理地址与线性地址的映射，即put_page()和get_empty_page()来进行相关的映射,put_page()把给定的线性地址和物理地址映射起来，而get_empty_page()只接受一个线性地址为参数，把其映射到随便一个新的物理页面。  
同时，当进程退出时，我们需要释放其使用的物理内存，同时我们也需要释放对应的页表，即free_page_tables，但是要进行这种释放只能是4M的线性地址空间。

### 共享内存空间
我们使用copy_page_tables()来进行页面的复制，即将两个不同的空间映射到相同的物理地址上，但是注意，为了简单(直接复制一个页表是比较简单的)，这种复制是以一个页表为单位的，也就是4M大小为单位。

### 进程的内存共享
有了前面的共享基础函数，我们就可以实现进程空间的共享了。  
当使用fork创建一个新的进程时，在共享进程时，我们直接对其代码和数据空间进行共享内存空间(copy_page_tables())来达到共享的目的。  
但是在之后进程执行的过程中，父进程和子进程可能执行到不同的阶段，进而分道扬镳。但是，父进程进行缺页中断获取了新的页表(或子进程)，而子进程(父进程)也可能执行到这个新的页表，那么这个页表也是可以共享的。也就是说，我们的原则就算只要不发生写操作，并且是一连串fork下来的进程，那么只要是可以共享的页面，我们都要尝试共享。即share_page()和try_to_share();其中share_page()调用try_to_share()来进行内存共享。

前面写了那么多，但是共享内存是在什么时候调用的呢，要知道当一个进程访问不到对应的页表时就会产生缺页中断，那么我们应该什么时候进行共享呢，就是在处理缺页中断的时候进行共享页面的检测。即page_fault和其调用的do_no_page();如果无法共享就为其分配新的页面。但是如果共享之后又产生了写操作应该怎么办呢？其实这个还是产生的缺页中断page_fault，并调用do_wp_page()来进行处理。
