---
title: 操作系统内存管理
description: 介绍操作系统的内存管理
tags: [Operating System]
---

## 要处理的问题
(这一段可以参考《程序员的自我修养——装载、链接与库》)
1. 需要尽可能的做到内存的充分利用(内存使用效率)
2. 地址空间不隔离，需要实现对内存的访问保护(防止恶意程序篡改)
3. 重定位问题。程序加载位置不确定因此对于许多jmp指令会不能正确跳转
### 直接使用物理空间
对于早期的操作系统访问内存，对内存的访问都是简单的，程序通过直接访问物理地址来进行编程。在这种情况下，内存的使用是不安全的，利用是不充分的，任何程序都可以访问相同的地址。当然，单个程序是没有问题的，但是对应多个程序，以上的所有问题都无法解决。

### 分段
对于不同程序内存的互相影响，我们可以想到的最简单的方法就是为每个程序划定一个内存空间，将某个程序限制在其自己的内存空间内，这样不就解决了对内存的混乱使用问题。因此，CPU设计者增加了相关分段部件，使用段+段内偏移的方式访问内存。同时，对于重定位问题，每个程序只需要关注自己的偏移就可以了。这个时候，我们可以稳定的允许多个程序了，但是我们知道，程序的内存占用是在不断变换的，这样，在两个程序段中间就会有一段难以利用的内存。**这个时候，分段对内存区域的映射还是以程序为单位**。如果内存不足，我们需要使用将暂时不用的程序放入磁盘中，从而严重影响速度。而事实上，根据程序的局部性原理，一段程序在一个时间段内只会用到一部分，因此，我们自然可以想到加载程序中一部分的代码来提高内存使用效率。

### 分页
为了只加载一部分代码，我们需要将程序进行分割，为了减少分割的复杂问题，我们可以直接把程序划分为固定大小，那么这个时候，程序加载到内存中也只会是一个固定大小，因此，我们同时可以对内存进行固定大小的划分，划分成和程序块相同的大小，这样因为程序大小不同而产生的无法利用的内存碎片也不会存在了。但是我们知道程序是一个整体，就算程序会经常允许部分代码，但是其他部分总是会执行。那么如果我们需要jmp到那一部分代码的时候，我们的内存中是没有的，那这不就会产生严重错误了吗。那么这个时候我们应该怎么办呢。解决方法就是在程序和实际内存之间增加一个中间层，这个中间层就算虚拟地址。即我们想办法实现这样一个中间层，对于程序来说，让其觉得是在访问实际的地址，但是对于实际的实现来说，却仅仅是加载部分程序，仅仅当跳转到未加载到内存中的程序段的时候再将跳转到的程序段加载到内存，但是这个过程程序是不知道的，它只会觉得它的程序是完全被加载到内存中的。很显然，仅仅使用编程是无法实现的，因为对地址的访问转换不是程序所能控制的，因此CPU设计者便增加了相关的电子部件，这就是虚拟分页部件。  
这个时候，对于虚拟地址空间的每一个块中的地址，经过分页部件的转换会映射到某个物理地址块的相应地址。也就是说，分页不仅仅实现了我们相要的功能，我们可以发现其实际上就是一个内存的映射(中间层)
:::tip
这个时候我们可以发现，这种情况下对于每个程序来说自己都是独占全部的内存空间，因此我们似乎又不用使用分段机制了，因为不会遇到重定位和内存充分利用的问题，因此Linux操作系统只使用了分页机制，几乎没有使用分段机制。因为分页机制几乎就算是高级的分段机制。
:::

## 操作系统内存管理设计
了解了基本的知识，我们应该如何设计操作系统的内存管理呢。
1. 将程序要使用的内存分成固定大小的内存块
2. 对内存块进行管理工作，管理其分配，回收
3. 建立分页机制，建立虚拟内存空间与物理地址空间的映射(不考虑分段机制)线性地址---分段--->虚拟地址---分页--->物理地址