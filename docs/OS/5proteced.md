---
title: 保护模式
description: 介绍保护模式
tags: [Operating System]
---

在操作系统中，感觉最没有存在感的就算保护模式，但是我们的程序就算靠保护模式安全运行的。我们在日常使用操作系统的时候甚至很难感受到保护的存在。

### 几个重要概念
在Intel开发者手册中描述了一些用来实现段保护机制的域,其中比较重要而且难以理解的有： 
* 描述符特权级(DPL): **(段描述符的第二个双字的第13和14位)**确定段的特权级 
* 请求特权级(RPL): **(段选择子的第0位和第一位)**确定段选择子的请求特权级
* 当前特权级(CPL): **(CS段寄存器的第0位和第1位)**指明当前执行程序/例程的特权级

### 1
为了实现对内存访问的限制，我们把所有的可访问内存分为4个级别(00,01,10,11)，为此，我们需要为每一个内存区域建立一个访问级别，因此，我们设计了段描述符，其中的特权级即为DPL(描述符特权级)，并且把这些段描述符放在一起形成段描述符表(GDT或LDT)。那么我们如何去访问一段内存区域呢，我们只需要段描述符表中的一个索引便可以去访问一段内存，于是我们设计了段选择子。但是如何判断我们是否有足够的特权级访问某个内存区域呢？我们知道，要去访问某段内存，我们的程序也运行在某段内存中，用CS段寄存器指向，因此，我们在段选择子中增加一个特权级域(CPL)，在我们访问某段内存时，CPU自动拿CPL和DPL进行比较来判断是否有足够的权限。即CS中是当前程序访问其他内存段的名片，当CPU检验你的名片有资格时才会允许你访问。但是为什么我们不直接在访问的时候使用的段选择子中的特权级位呢，而是使用加载到CS中的CPL。这是因为段选择子中的特权级别有它用，即作为RPL使用，**是谁请求就为RPL域赋上其CPL**，用来表明访问某段资源的程序的真实身份。那么难道CS段寄存器中的不是真实身份吗，可能不是，因为低特权级要想访问高特权级资源就需要允行在高特权级，但是又需要辨别其真实身份，因此就需要RPL。

### 2




但是别忘了还有特权级的事，既然内存区域有特权级，那么我们如何表明我们(访问者)的特权级呢？即在索引(段选择子)中增加一个特权级域，